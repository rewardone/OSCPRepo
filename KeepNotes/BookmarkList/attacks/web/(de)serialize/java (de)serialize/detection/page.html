<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Detection</title>
</head><body><a href="https://github.com/federicodotta/Java-Deserialization-Scanner/releases">https://github.com/federicodotta/Java-Deserialization-Scanner/releases</a>&nbsp;- scanner referenced <br/>
<b><br/>
</b><b>Detection</b><br/>
<br/>
The detection of deserialization vulnerabilities is not always a simple task. By generating a payload with ysoserial and sending it to the target application, usually we may either get a Java Stack Trace (and if we are lucky we can discover the presence of the issue, but only with a knowledge of the vulnerable library targeted) or no verbose output at all.<br/>
<br/>
Therefore, in order to reliably detect the presence of the vulnerability, we modified ysoserial to generate Java native sleep payloads instead of RCE payloads and we added these payloads to the Java Deserialization Scanner. For this task it is necessary to use Java native sleep payloads, because the Java sleep call is synchronous; executing a system sleep using the default RCE payloads generated by ysoserial would be useless, because they are asynchronous and we would get the response from the server before the end of the sleep command, regardless of the presence or the absence of the issue.<br/>
<br/>
In the latest version of the plugin, we added two new methods to further improve detection: one based on DNS and one on CPU.<br/>
<br/>
In order to generate payloads that execute native Java DNS resolution, we modified ysoserial again. Usually, DNS resolution requests are the ones that are most likely to bypass corporate firewalls and consequently are a quite good detection method. In general, the timing method is more reliable and preferable, but the DNS method can be useful on unstable systems or highly delayed networks. Thanks to Burp Suite Collaborator, it is not necessary to have authority on a DNS zone, and everything can be done within the Burp Suite tool.<br/>
<br/>
The CPU detection method is based on Wouter Coekaerts’ SerialDOS work: it is able to detect deserialization issues without the presence of any vulnerable library. The payload is based on a system object (java.util.HashSet) that employs many CPU cycles for the deserialization task. SerialDOS was created as a PoC of a Denial of Service (DoS) attack, but by decreasing the CPU cycles necessary for deserialization it can also be used as a detection method. This payload is very useful to detect if the application endpoint actually performs Java deserialization and if it implements a strict whitelist approach. If this check gives a positive result there is also the possibility that the target application implements a whitelist approach that permits HashSet class of java.util package. In this case the application is still vulnerable to DoS attacks (using full-power SerialDOS payloads).<br/>
<br/>
Now, let’s demonstrate how to use our plugin for detection. The detection is integrated in Burp Suite Active and Passive Scanner. By default, Time and DNS checks are added to Burp Suite scanner, but they can be disabled from the Configurations panel of the plugin, in the section “Automatic scanner configurations”:<br/>
<br/>
In order to reduce the number of requests executed by the Active Scanner, the checks added by the plugin are executed only if a serialized object is present in the original request. The payload is encoded with the same encoding found in the original request (for instance, if the serialized object is encoded in BASE64, the exploit vector will be encoded in BASE64 and so on). The currently supported encoding formats are:<br/>
<br/>
Raw<br/>
BASE64<br/>
ASCII HEX<br/>
GZIP<br/>
BASE64 GZIP<br/>
<br/>
The CPU detection method is not included by default in the active scan checks, because it must be used with caution: sending a huge number of “light” SerialDOS payloads may still cause problems on old or highly-loaded systems. In order to execute checks with custom insertion points or use the CPU payload, the plugin provides the “Manual Testing” tab, in which the user can select the insertion point (currently only one at a time is supported) like in the Burp Suite Intruder, choose the check type (DNS, Time, or CPU), choose the preferred encoding and test the parameter. By selecting Sleep or DNS checks, the plugin tests all the supported vulnerable libraries, while with the CPU check the plugin will use a library-independent CPU payload. By default, detected issues are automatically added to the global issues of the host, but this behavior can be disabled in the “Configurations” tab. In the same tab it is possible to enable verbose mode, in order to inspect the requests and their responses in the results pane.<br/>
<br/>
The requests to test can be manually inserted in the Manual Testing tab or can be sent from other Burp Suite tabs using the contextual menu that opens with the right button of the mouse:<br/>
<br/>
<b>Exploitation</b><br/>
<br/>
The “Exploiting” tab offers a comfortable interface to exploit deserialization vulnerabilities. This tab uses the ysoserial tool to generate exploitation vectors and includes the generated payload in a HTTP request. ysoserial takes as argument a vulnerable library and a command and generates a serialized object in binary form that can be sent to the vulnerable application to execute the command on the target system (obviously if the target application is vulnerable). The Exploiting tab supports the same encoding formats as the detection sections of the plugin.<br/>
<br/>
Now, let’s demonstrate how to use our plugin for exploitation. First, we need to open the “Configuration” tab and insert the path where we have a copy of the ysoserial tool (ysoserial is necessary only for exploitation; detection payloads are already included in the plugin):<br/>
<br/>
Then, as we saw for manual testing, it is possible to insert the request manually or to send it from other Burp Suite tabs using the contextual menu that opens with the right button of the mouse. The user can then select the insertion point (currently only one at a time is supported) like in the Burp Suite Intruder, insert the ysoserial command (refer to the ysoserial manual for syntax) and click the correct “Attack” button, based on the desired encoding. The configuration of the “Exploiting” tool is explained in the following picture:<br/>
<br/>
The interface provided by the plugin makes the exploitation process faster and more comfortable.<br/>
<br/>
<br/>
<br/>
<b>Manual Detection</b><br/>
If you have access to the apps source, you can check for vulnerable libraries that are bundled. Two checks for the common-collections libaries are: "*commons*collection*" and "InvokerTransformer".<br/>
For example in WebSphere:<br/>
<br/>
root@us-l-breens:/opt/IBM# find . -iname "*commons*collection*"<br/>
./WebSphere/AppServer/optionalLibraries/Apache/Struts/1.1/commons-collections.jar<br/>
./WebSphere/AppServer/optionalLibraries/Apache/Struts/1.2.4/commons-collections.jar<br/>
./WebSphere/AppServer/plugins/com.ibm.ws.prereq.commons-collections.jar<br/>
./WebSphere/AppServer/systemApps/LongRunningScheduler.ear/JobManagementWeb.war/WEB-INF/lib/commons-collections.jar<br/>
./WebSphere/AppServer/systemApps/isclite.ear/commons-collections.jar<br/>
./WebSphere/AppServer/deploytool/itp/plugins/com.ibm.websphere.v85_2.0.0.v20120621_2102/wasJars/com.ibm.ws.prereq.commons-collections.jar<br/>
<br/>
In JBOSS<br/>
root@us-l-breens:/opt/jboss-6.1.0.Final# grep -R InvokerTransformer .<br/>
Binary file ./server/standard/deployers/jsf.deployer/MyFaces-2.0/jsf-libs/commons-collections-3.2.jar matches<br/>
Binary file ./server/all/deployers/jsf.deployer/MyFaces-2.0/jsf-libs/commons-collections-3.2.jar matches<br/>
Binary file ./server/default/deployers/jsf.deployer/MyFaces-2.0/jsf-libs/commons-collections-3.2.jar matches<br/>
Binary file ./common/deploy/admin-console.war/WEB-INF/lib/commons-collections-3.2.jar matches<br/>
Binary file ./common/lib/commons-collections.jar matches<br/>
Binary file ./client/commons-collections.jar matches<br/>
<br/>
<br/>
Incertect traffinc. Looking for certain strings being passed:<br/>
<b>hex 0xAC ED</b>&nbsp;<b>00 05</b>&nbsp;or the <b>base64</b>&nbsp;<b>rO0</b>&nbsp;. . . <br/>
These are the serialized objects.<br/>
<br/>
Sometimes an HTTP header needs to be included in requests. <br/>
Content-Type: application/x-java-serialized-object<br/>
</body></html>