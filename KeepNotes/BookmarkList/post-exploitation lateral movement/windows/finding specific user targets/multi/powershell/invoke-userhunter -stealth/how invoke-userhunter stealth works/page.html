<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>How Invoke-UserHunter Stealth Works</title>
</head><body>Invoke-StealthUserHunter works differently. StealthUserHunter attempts to be quieter and faster by only querying systems in the domain that provide the most value. In a Windows domain, fileservers and domain controllers are the most fruitful targets for gathering a large number of user sessions. <br/>
<br/>
StealthUserHunter begins by querying for users of interest like the regular UserHunter. <br/>
Next, it calls Get-NetFileServers, which extracts the computer names from the home directories, script paths, and profile paths of users in the domain. <br/>
Then the script will call Get-NetDomainControllers and add these as well to the host list. <br/>
Finally, it will perform a Get-NetSessions against all of the servers in the host list and compare it against the target user group.<br/>
<br/>
Since only one Get-NetSessions call is issued against a handful of high-traffic servers, this will complete much faster than the regular UserHunter. It should also do a better job of flying under the radar as it sends out significantly less traffic. While StealthUserHunter’s coverage isn’t as accurate, it usually gives us a good mapping and is our default method of choice on most engagements.<br/>
<br/>
*If you want the raw dump of where all of the users are logged in, you can add a -ShowAll flag to the user hunter scripts. I prefer this so we do not have to query multiple times!</body></html>