<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Popular Jump Techniques</title>
</head><body>There are multiple methods of forcing the execution of shellcode.<ul><li>&nbsp;<b>jump (or call)</b>&nbsp;a register that points to the shellcode. With this technique, you basically use a register that contains the address where the shellcode resides and put that address in EIP. You try to find the opcode of a “jump” or “call” to that register in one of the dll’s that is loaded when the application runs. When crafting your payload, instead of overwriting EIP with an address in memory, you need to overwrite EIP with the address of the “jump to the register”. Of course, this only works if one of the available registers contains an address that points to the shellcode. This is how we managed to get our exploit to work in part 1, so I’m not going to discuss this technique in this post anymore. </li>
<li><b>pop return</b>&nbsp;: If none of the registers point directly to the shellcode, but you can see an address on the stack (first, second, … address on the stack) that points to the shellcode, then you can load that value into EIP by first putting a pointer to pop ret, or pop pop ret, or pop pop pop ret (all depending on the location of where the address is found on the stack) into EIP. </li>
<li style="list-style-type: none"><ul><li>POP takes 4 bytes off the top of the stack. RET takes the value at the current address of ESP and puts it in EIP. If the value contains a JMP ESP instruction, then that is what EIP would then do. Essentially, feed POP up to a JMP or CALL instruction. Or POP until it reaches an attacker controlled value, the attacker places JMP &lt;register&gt;, and the attacker just needs to overwrite EIP with POP RET to go wherever the attacker wants.</li>
</ul>
</li>
<li><b>push return</b>&nbsp;: this method is only slightly different than the “call register” technique. If you cannot find a &nbsp;or &nbsp;opcode anywhere, you could simply put the address on the stack and then do a ret. So you basically try to find a push , followed by a ret. Find the opcode for this sequence, find an address that performs this sequence, and overwrite EIP with this address. </li>
<li><b>jmp [reg + offset]</b>&nbsp;: If there is a register that points to the buffer containing the shellcode, but it does not point at the beginning of the shellcode, you can also try to find an instruction in one of the OS or application dll’s, which will add the required bytes to the register and then jumps to the register. I’ll refer to this method as jmp [reg]+[offset] </li>
<li><b>blind return</b>&nbsp;: in my previous post I have explained that ESP points to the current stack position (by definition). A RET instruction will ‘pop’ the last value (4bytes) from the stack and will put that address in ESP. So if you overwrite EIP with the address that will perform a RET instruction, you will load the value stored at ESP into EIP. </li>
<li>If you are faced with the fact that the available space in the buffer (after the EIP overwrite) is limited, but you have plenty of space before overwriting EIP, then you could use<b>&nbsp;jump code</b>&nbsp;in the smaller buffer to jump to the main shellcode in the first part of the buffer. </li>
<li><u><b>SEH </b></u>: Every application has a default exception handler which is provided for by the OS. So even if the application itself does not use exception handling, you can try to overwrite the SEH handler with your own address and make it jump to your shellcode. Using SEH can make an exploit more reliable on various windows platforms, but it requires some more explanation before you can start abusing the SEH to write exploits. The idea behind this is that if you build an exploit that does not work on a given OS, then the payload might just crash the application (and trigger an exception). So if you can combine a “regular” exploit with a seh based exploit, then you have build a more reliable exploit. Anyways, the next part of the exploit writing tutorial series (part 3) will deal with SEH. Just remember that a typical stack based overflow, where you overwrite EIP, could potentionally be subject to a SEH based exploit technique as well, giving you more stability, a larger buffer size (and overwriting EIP would trigger SEH… so it’s a win win) </li>
</ul>
</body></html>