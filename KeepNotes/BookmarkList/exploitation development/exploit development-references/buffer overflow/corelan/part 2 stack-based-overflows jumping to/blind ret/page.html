<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Blind RET</title>
</head><body>This technique is based on the following 2 steps:<br/>
<ul><li>Overwrite EIP with an address pointing to a ret instruction</li>
<li>Hardcode the address of the shellcode at the first 4 bytes of ESP</li>
<li>When the ret is execute, the last added 4 bytes (topmost value) are popped from the stack and will be put in EIP</li>
<li>Exploit jumps to shellcode</li>
</ul>
<br/>
So this technique is useful if<br/>
<ul><li>you cannot point EIP to go a register directly (because you cannot use jmp or call instructions. (This means that you need to hardcode the memory address of the start of the shellcode), but</li>
<li>you can control the data at ESP (at least the first 4 bytes)</li>
</ul>
<br/>
In order to set this up, you need to have the memory address of the shellcode (= the address of ESP). As usual, try to avoid that this address starts with / contains null bytes, or you will not be able to load your shellcode behind EIP. If your shellcode can be put at a location, and this location address does not contain a null byte, then this would be another working technique.<br/>
<br/>
Find the address of a ‘ret’ instruction in one of the dll’s.<br/>
<br/>
Set the first 4 bytes of the shellcode (first 4 bytes of ESP) to the address where the shellcode begins, and overwrite EIP with the address of the ‘ret’ instruction. From the tests we have done in the first part of this tutorial, we remember that ESP seems to start at 0x000ff730. Of course this address could change on different systems, but if you have no other way than hardcoding addresses, then this is the only thing you can do.<br/>
<br/>
This address contains null byte, so when building the payload, we create a buffer that looks like this :<br/>
<br/>
[26094 A’s][address of ret][0x000fff730][shellcode]<br/>
<br/>
The problem with this example is that the address used to overwrite EIP contains a null byte. (= string terminator), so the shellcode is not put in ESP. This is a problem, but it may not be a showstopper. Sometimes you can find your buffer (look at the first 26094 A’s, not at the ones that are pushed after overwriting EIP, because they will be unusable because of null byte) back at other locations/registers, such as eax, ebx, ecx, etc… In that case, you could try to put the address of that register as the first 4 bytes of the shellcode (at the beginning of ESP, so directly after overwriting EIP), and still overwrite EIP with the address of a ‘ret’ instruction.<br/>
<br/>
This is a technique that has a lot of requirements and drawbacks, but it only requires a “ret” instruction… Anyways, it didn’t really work for Easy RM to MP3.</body></html>