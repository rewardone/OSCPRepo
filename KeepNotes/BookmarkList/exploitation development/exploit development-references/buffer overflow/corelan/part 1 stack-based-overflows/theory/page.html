<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Theory</title>
</head><body>Every Windows application uses parts of memory. The process memory contains 3 major components :<br/>
&nbsp;<ul><li>code segment (instructions that the processor executes. The EIP keeps track of the next instruction) </li>
<li>data segment (variables, dynamic buffers) </li>
<li>stack segment (used to pass data/arguments to functions, and is used as space for variables. The stack starts (= the bottom of the stack) from the very end of the virtual memory of a page and grows down (to a lower address). a PUSH adds something to the top of the stack, POP will remove one item (4 bytes) from the stack and puts it in a register. </li>
</ul>
<br/>
If you want to access the stack memory directly, you can use ESP (Stack Pointer), which points at the top (so the lowest memory address) of the stack.<br/>
&nbsp;<ul><li>After a push, ESP will point to a lower memory address (address is decremented with the size of the data that is pushed onto the stack, which is 4 bytes in case of addresses/pointers). Decrements usually happen before the item is placed on the stack (depending on the implementation… if ESP already points at the next free location in the stack, the decrement happens after placing data on the stack) </li>
<li>After a POP, ESP points to a higher address (address is incremented (by 4 bytes in case of addresses/pointers)). Increments happen after an item is removed from the stack. </li>
</ul>
<br/>
When a function/subroutine is entered, a stack frame is created. This frame keeps the parameters of the parent procedure together and is used to pass arguments to the subrouting. The current location of the stack can be accessed via the stack pointer (ESP), the current base of the function is contained in the base pointer (EBP) (or frame pointer).<br/>
&nbsp;<br/>
The CPU’s general purpose registers (Intel, x86) are :<br/>
&nbsp;<ul><li>EAX : accumulator : used for performing calculations, and used to store return values from function calls. Basic operations such as add, subtract, compare use this general-purpose register </li>
<li>EBX : base (does not have anything to do with base pointer). It has no general purpose and can be used to store data. </li>
<li>ECX : counter : used for iterations. ECX counts downward. </li>
<li>EDX : data : this is an extension of the EAX register. It allows for more complex calculations (multiply, divide) by allowing extra data to be stored to facilitate those calculations. </li>
<li>ESP : stack pointer </li>
<li>EBP : base pointer </li>
<li>ESI : source index : holds location of input data </li>
<li>EDI : destination index: points to location of where result of data operation is stored </li>
<li>EIP : instruction pointer </li>
</ul>
<br/>
</body></html>