<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>The Debugger</title>
</head><body>In order to see the state of the stack (and value of registers such as the instruction pointer, stack pointer etc), we need to hook up a debugger to the application, so we can see what happens at the time the application runs (and especially when it dies).<br/>
<br/>
There are many debuggers available for this purpose. The two debuggers I use most often are Windbg, and Immunity’s Debugger<br/>
Let’s use Windbg. Install Windbg (Full install) and register it as a “post-mortem” debugger using “windbg -I”<br/>
<br/>
You can also disable the “xxxx has encountered a problem and needs to close” popup by setting the following registry key :<br/>
HKLM\Software\Microsoft\Windows NT\CurrentVersion\AeDebug\Auto : set to 0<br/>
<br/>
In order to avoid Windbg complaining about Symbol files not found, create a folder on your harddrive (let’s say c:\windbgsymbols). Then, in Windbg, go to “File” – “Symbol File Path” and enter the following string :<br/>
&nbsp; &nbsp; SRV*C:\windbgsymbols*http://msdl.microsoft.com/download/symbols<br/>
(do NOT put an empty line after this string ! make sure this string is the only string in the symbol path field)<br/>
<br/>
If you want to use Immunity Debugger instead : get a copy here and install it. Open Immunity debugger, go to "Options" – "Just in-time debugging" and click "Make Immunity Debugger just in-time debugger".<br/>
<br/>
Launch Easy RM to MP3, and then open the crash.m3u file again. The application will crash again. If you have disabled the popups, windbg or Immunity debugger will kick in automatically. If you get a popup, click the “debug” button and the debugger will be launched :<br/>
<br/>
This GUI shows the same information, but in a more…errr.. graphical way. In the upper left corner, you have the CPU view, which shows assembly instructions and their opcodes. (the window is empty because EIP currently points at 41414141 and that’s not a valid address). In the upper right windows, you can see the registers. In the lower left corner, you see the memory dump of 00446000 in this case. In the lower right corner, you can see the contents of the stack (so the contents of memory at the location where ESP points at).<br/>
<br/>
Anyways, in both cases, we can see that the instruction pointer contains 41414141, which is the hexidecimal representation for AAAA.<br/>
<br/>
&nbsp; &nbsp; A quick note before proceeding : On intel x86, the addresses are stored little-endian (so backwards). The AAAA you are seeing is in fact AAAA :-) (or, if you have sent ABCD in your buffer, EIP would point at 44434241 (DCBA)<br/>
<br/>
So it looks like part of our m3u file was read into the buffer and caused the buffer to overflow. We have been able to overflow the buffer and write across the instruction pointer. So we may be able to control the value of EIP.<br/>
<br/>
Since our file does only contain A’s, we don’t know exactly how big our buffer needs to be in order to write exactly into EIP. In other words, if we want to be specific in overwriting EIP (so we can feed it usable data and make it jump to our evil code, we need to know the exact position in our buffer/payload where we overwrite the return address (which will become EIP when the function returns). This position is often referred to as the “offset”.<br/>
<br/>
<br/>
<br/>
</body></html>