<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>The Stack</title>
</head><body>The <a href="http://en.wikipedia.org/wiki/Stack-based_memory_allocation">stack</a>&nbsp;is a piece of the process memory, a data structure that works LIFO (Last in first out). A stack gets allocated by the OS, for each thread (when the thread is created). When the thread ends, the stack is cleared as well. The size of the stack is defined when it gets created and doesn’t change. Combined with LIFO and the fact that it does not require complex management structures/mechanisms to get managed, the stack is pretty fast, but limited in size.<br/>
&nbsp;<br/>
LIFO means that the most recent placed data (result of a PUSH instruction) is the first one that will be removed from the stack again. (by a POP instruction).<br/>
&nbsp;<br/>
When a stack is created, the stack pointer points to the top of the stack ( = the highest address on the stack). As information is pushed onto the stack, this stack pointer decrements (goes to a lower address). So in essence, <b>the stack grows to a lower address.</b><br/>
&nbsp;<br/>
The stack contains local variables, function calls and other info that does not need to be stored for a larger amount of time. As more data is added to the stack (pushed onto the stack), the stack pointer is decremented and points at a lower address value.<br/>
&nbsp;<br/>
Every time a function is called, the function parameters are pushed onto the stack, as well as the saved values of registers (EBP, EIP). When a function returns, the saved value of EIP is retrieved from the stack and placed back in EIP, so the normal application flow can be resumed.<br/>
&nbsp;<br/>
Let’s use a few lines of simple code to demonstrate the behaviour :<br/>
#include &nbsp;<br/>
<br/>
void do_something(char *Buffer)<br/>
{<br/>
&nbsp; &nbsp; &nbsp;char MyVar[128];<br/>
&nbsp; &nbsp; &nbsp;strcpy(MyVar,Buffer);<br/>
}<br/>
<br/>
int main (int argc, char **argv)<br/>
{<br/>
&nbsp; &nbsp; &nbsp;do_something(argv[1]);<br/>
}<br/>
<br/>
This applications takes an argument (argv[1] and passes the argument to function do_something(). In that function, the argument is copied into a local variable that has a maximum of 128 bytes. So… if the argument is longer than 127 bytes (+ a null byte to terminate the string), the buffer may get overflown.<br/>
&nbsp;<br/>
When function "do_something(param1)" gets called from inside main(), the following things happen :<br/>
&nbsp;<br/>
A new stack frame will be created, on top of the ‘parent’ stack. The stack pointer (ESP) points to the highest address of the newly created stack. This is the "top of the stack".<br/>
<br/>
<img src="image.png" /><br/>
<br/>
Before do_something() is called, a pointer to the argument(s) gets pushed to the stack. In our case, this is a pointer to argv[1].<br/>
Next, function do_something is called. The CALL instruction will first put the current instruction pointer onto the stack (so it knows where to return to if the function ends) and will then jump to the function code.<br/>
As a result of the push, ESP decrements 4 bytes and now points to a lower address.<br/>
<br/>
<img src="image 2.png" /><br/>
<br/>
Next, the function prolog executes. This basically saves the frame pointer (EBP) onto the stack, so it can be restored as well when the function returns. The instruction to save the frame pointer is "push ebp". ESP is decremented again with 4 bytes.<br/>
<br/>
<img src="image 3.png" /><br/>
Following the push ebp, the current stack pointer (ESP) is put in EBP. At that point, both ESP and EBP point at the top of the current stack. From that point on, the stack will usually be referenced by ESP (top of the stack at any time) and EBP (the base pointer of the current stack). This way, the application can reference variables by using an offset to EBP.<br/>
<br/>
Tip: Most functions start with this sequence : PUSH EBP, followed by MOV EBP,ESP<br/>
<br/>
So, if you would push 4 bytes to the stack, ESP would decrement with 4 bytes and EBP would still stay where it was. You can then reference these 4 bytes using EBP-0x4.<br/>
&nbsp;<br/>
Next, we can see how stack space for the variable MyVar (128bytes) is declared/allocated. In order to hold the data, some space is allocated on the stack to hold data in this variable… ESP is decremented by a number of bytes. This number of bytes wil most likely be more than 128 bytes, because of an allocation routine determined by the compiler. In the case of Dev-C++, this is 0x98 bytes. So you will see a SUB ESP,0x98 instruction. That way, there will be space available for this variable.<br/>
<br/>
<img src="image 4.png" /><br/>
The disassembly of the function looks like this :<br/>
<br/>
00401290 &nbsp;/$ 55 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#09;&#09;PUSH EBP<br/>
00401291 &nbsp;|. 89E5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#09;MOV EBP,ESP<br/>
00401293 &nbsp;|. 81EC 98000000 &nbsp;SUB ESP,98<br/>
00401299 &nbsp;|. 8B45 08 &nbsp; &nbsp; &nbsp; &nbsp;&#09;MOV EAX,DWORD PTR SS:[EBP+8]&#09;; |<br/>
0040129C &nbsp;|. 894424 04 &nbsp; &nbsp; &nbsp;&#09;MOV DWORD PTR SS:[ESP+4],EAX&#09;; |<br/>
004012A0 &nbsp;|. 8D85 78FFFFFF &nbsp;LEA EAX,DWORD PTR SS:[EBP-88]&#09;; |<br/>
004012A6 &nbsp;|. 890424 &nbsp; &nbsp; &nbsp; &nbsp; &#09;MOV DWORD PTR SS:[ESP],EAX&#09;&#09;; |<br/>
004012A9 &nbsp;|. E8 72050000 &nbsp; &nbsp;&#09;CALL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; \strcpy<br/>
004012AE &nbsp;|. C9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#09;&#09;LEAVE<br/>
004012AF &nbsp;\. C3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#09;&#09;RETN<br/>
<br/>
You can clearly see the function prolog (PUSH EBP and MOV EBP,ESP), you can also see where space gets allocated for MyVar (SUB ESP,98), and you can see some MOV and LEA instructions (which basically set up the parameters for the strcpy function… taking the pointer where argv[1] sits and using it to copy data from, into MyVar.<br/>
If there would not have been a strcpy() in this function, the function would now end and "unwind" the stack. Basically, it would just move ESP back to the location where saved EIP was, and then issues a RET instruction. A ret, in this case, will pick up the saved EIP pointer from the stack and jump to it. (thus, it will go back to the main function, right after where do_something() was called). The epilog instruction is executed by a LEAVE instruction (which will restore both the framepointer and EIP).<br/>
<br/>
In my example, we have a strcpy() function.<br/>
<br/>
This function will read data, from the address pointed to by [Buffer], and store it in , reading all data until it sees a null byte (string terminator). While it copies the data, ESP stays where it is. The strcpy() does not use PUSH instructions to put data on the stack… it basically reads a byte and writes it to the stack, using an index (for example ESP, ESP+1, ESP+2, etc). So after the copy, ESP still points at the begin of the string.<br/>
<br/>
<img src="image 5.png" /><br/>
That means… If the data in [Buffer] is somewhat longer than 0x98 bytes, the strcpy() will overwrite saved EBP and eventually saved EIP (and so on). After all, it just continues to read &amp; write until it reaches a null byte in the source location (in case of a string)<br/>
<br/>
<img src="image 6.png" /><br/>
ESP still points at the begin of the string. The strcpy() completes as if nothing is wrong. After the strcpy(), the function ends. And this is where things get interesting. The function epilog kicks in. Basically, it will move ESP back to the location where saved EIP was stored, and it will issue a RET. It will take the pointer (AAAA or 0x41414141 in our case, since it got overwritten), and will jump to that address.<br/>
<br/>
So you control EIP.<br/>
<br/>
Long story short, by controlling EIP, you basically change the return address that the function will uses in order to “resume normal flow”.<br/>
<br/>
Of course, if you change this return address by issuing a buffer overflow, it’s not a “normal flow” anymore.<br/>
<br/>
So… Suppose you can overwrite the buffer in MyVar, EBP, EIP and you have A’s (your own code) in the area before and after saved EIP… think about it. After sending the buffer ([MyVar][EBP][EIP][your code]), ESP will/should point at the beginning of [your code]. So if you can make EIP go to your code, you’re in control.<br/>
<br/>
Note : when a buffer on the stack overflows, the term "stack based overflow" or "stack buffer overflow" is used. When you are trying to write past the end of the stack frame, the term "stack overflow" is used. Don’t mix those two up, as they are entirely different.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
</body></html>