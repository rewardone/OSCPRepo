<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Event Consumers</title>
</head><body>Another means of achieving code execution is to create a permanent WMI event subscription. Normally, a<br/>
permanent WMI event subscription is designed to persist and respond to certain events. If an attacker wanted<br/>
to execute a single payload however, they could just configure an event consumer to delete its corresponding<br/>
event filter, consumer, and filter to consumer binding. The advantage of this technique is that the payload runs<br/>
as a SYSTEM process and it avoids having a payload be displayed in plaintext in the presence of commandline<br/>
auditing. For example, if a VBScript ActiveScriptEventConsumer payload was utilized, the only process created would be the following WMI script host process:<br/>
%SystemRoot%\system32\wbem\scrcons.exe -Embedding<br/>
<br/>
As an attacker, the challenge for pursuing this class of attack vector would be selecting an intelligent event filter. If they just wanted to trigger the payload after a few seconds, an __IntervalTimerInstruction class could be used. An attacker might choose to execute the payload upon a user locking their screen. In that case, an extrinsic Win32_ProcessStartTrace event could be used to trigger upon the LogonUI.exeprocess being created. An attacker can get creative in their choice of an appropriate event filter</body></html>